This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
app/
  app.vue
assets/
  css/
    tailwind.css
components/
  canvas/
    base/
      BaseNodeShell.vue
    node/
      CardOverlay.vue
      LightweightText.vue
    MindMapNode.vue
  icon/
    CloseIcon.vue
    HeartIcon.vue
    Logo.vue
  landing/
    FeaturesSection.vue
    HeroSection.vue
    LandingHeader.vue
  modals/
    BaseModal.vue
  ui/
    Button.vue
  Header.vue
  SearchCard.vue
composables/
  useMindMapLayout.ts
layouts/
  blank.vue
  default.vue
middleware/
  auth.global.ts
pages/
  app.vue
  index.vue
  login.vue
  register.vue
plugins/
  click-outside.ts
  supabase.client.ts
public/
  robots.txt
stores/
  mindMapStore.ts
types/
  components.d.ts
  global.d.ts
  imports.d.ts
  nuxt-app.d.ts
  nuxt-config.d.ts
  nuxt-tailwindcss.d.ts
  nuxt.d.ts
  supabase.d.ts
  supabase.ts
  tailwind.d.ts
  v-click-outside.d.ts
  vue-flow-controls.d.ts
.env.example
.gitignore
components.d.ts
nuxt.config.ts
nuxt.tsconfig.json
package.json
README.md
tailwind.config.js
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="components/canvas/base/BaseNodeShell.vue">
<template>
  <!-- Base shell with fixed size and slots for content and overlay -->
  <div
    class="relative"
    :style="{
      width: width + 'px',
      height: height + 'px',
      contain: 'layout style',
    }"
    v-bind="$attrs"
    :data-debug-overlay="showOverlay ? 'visible' : 'hidden'"
    @mouseenter="onMouseEnter"
    @mouseleave="onMouseLeave"
  >
    <!-- Base content (lightweight). Maintains footprint, centered. -->
    <div
      class="absolute inset-0 flex items-center justify-center transition-opacity duration-200"
      :class="showOverlay ? 'opacity-0' : 'opacity-100'"
      style="pointer-events: none"
    >
      <slot />
    </div>

    <!-- Overlay for the card, controlled externally. Doesn't change node size. -->
    <transition
      name="fade"
      mode="out-in"
      @before-enter="onBeforeEnter"
      @enter="onEnter"
      @after-enter="onAfterEnter"
      @before-leave="onBeforeLeave"
      @leave="onLeave"
      @after-leave="onAfterLeave"
    >
      <div
        v-if="showOverlay"
        class="absolute inset-0 z-10 transition-opacity duration-200"
        style="transform: translateZ(0); pointer-events: auto"
        @click="handleOverlayClick"
      >
        <div
          v-if="!slots.overlay"
          class="w-full h-full flex items-center justify-center bg-red-500/10"
        >
          <div class="text-xs text-red-500 p-2 bg-white/90 rounded">
            No overlay slot content provided
          </div>
        </div>
        <slot v-else name="overlay" />
      </div>
    </transition>
  </div>
</template>

<script setup lang="ts">
import * as Vue from "vue";
const onMouseEnter = () => {
  console.log("BaseNodeShell - mouseenter", {
    showOverlay: props.showOverlay,
    timestamp: new Date().toISOString(),
  });
};
const onMouseLeave = () => {
  console.log("BaseNodeShell - mouseleave", {
    showOverlay: props.showOverlay,
    timestamp: new Date().toISOString(),
  });
};
const onBeforeEnter = () =>
  console.log("Overlay - before enter", {
    timestamp: new Date().toISOString(),
  });
const onEnter = () =>
  console.log("Overlay - enter", { timestamp: new Date().toISOString() });
const onAfterEnter = () =>
  console.log("Overlay - after enter", { timestamp: new Date().toISOString() });
const onBeforeLeave = () =>
  console.log("Overlay - before leave", {
    timestamp: new Date().toISOString(),
  });
const onLeave = () =>
  console.log("Overlay - leave", { timestamp: new Date().toISOString() });
const onAfterLeave = () =>
  console.log("Overlay - after leave", { timestamp: new Date().toISOString() });
const handleOverlayClick = (e: MouseEvent) => {
  console.log("Overlay - click", {
    target: e.target,
    currentTarget: e.currentTarget,
    hasOverlaySlot: !!slots.overlay,
    timestamp: new Date().toISOString(),
  });
  e.stopPropagation();
};

// Component props with TypeScript interface
interface Props {
  width: number;
  height: number;
  showOverlay: boolean;
  debug?: boolean;
}

const props = withDefaults(defineProps<Props>(), {
  debug: false,
});

const slots = Vue.useSlots();

/**
 * BaseNodeShell
 * - Garante footprint fixo do nó no canvas.
 * - Usa slots: padrão (conteúdo lightweight) e `overlay` (card absoluto).
 * - Não aplica estilos visuais (cor/borda/sombra) — só tamanho e posicionamento.
 */

// Log component lifecycle and props changes
const logState = (context: string): void => {
  if (!props.debug) return;

  console.log(`[BaseNodeShell] ${context}:`, {
    width: props.width,
    height: props.height,
    showOverlay: props.showOverlay,
    hasDefaultSlot: !!slots?.default,
    hasOverlaySlot: !!slots?.overlay,
    timestamp: new Date().toISOString(),
  });
};

// Component lifecycle hooks
Vue.onMounted(() => logState("Mounted"));
Vue.onUpdated(() => logState("Updated"));

// Watch for showOverlay changes
Vue.watch(
  () => props.showOverlay,
  (newVal: boolean, oldVal: boolean) => {
    if (!props.debug) return;

    console.log("[BaseNodeShell] showOverlay changed:", {
      from: oldVal,
      to: newVal,
      timestamp: new Date().toISOString(),
    });
  },
  { immediate: true, flush: "post" }
);
</script>
</file>

<file path="components/canvas/node/CardOverlay.vue">
<template>
  <!-- Card overlay for non-root nodes -->
  <div
    ref="cardRef"
    class="w-full h-full p-3 rounded-lg bg-[#1d1d1f] border-t border-t-[#47464B] shadow-lg transition-all duration-200 flex items-start gap-2 transform hover:scale-[1.02] hover:shadow-xl hover:z-20"
    :data-node-id="nodeId"
    :data-visible="isVisible"
    style="backface-visibility: hidden; transform-style: preserve-3d; will-change: transform, box-shadow; pointer-events: auto;"
    @mouseenter="onMouseEnter"
    @mouseleave="onMouseLeave"
  >
    <!-- Ícone opcional -->
    <div class="mt-0.5" v-if="$slots.icon">
      <slot name="icon" />
    </div>

    <!-- Conteúdo principal -->
    <div class="flex-1 min-w-0">
      <div class="font-semibold text-lg text-white truncate">
        {{ label }}
      </div>
      <div v-if="description" class="text-xs text-white/80 mt-1 line-clamp-3">
        {{ description }}
      </div>

      <!-- Slot extra opcional (tags, métricas, etc.) -->
      <div v-if="$slots.default" class="mt-2">
        <slot />
      </div>

      <!-- Ações -->
      <div class="mt-3 flex gap-2">
        <slot name="actions">
          <UiButton v-if="ctaText" @click.stop="onPrimary()">
            {{ ctaText }}
          </UiButton>
        </slot>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
// Explicitly import Vue Composition API functions
import { useSlots, onMounted, watch, ref } from 'vue';
import type { Ref } from 'vue';

// Component props with TypeScript interface
interface Props {
  label: string;
  description?: string;
  ctaText?: string;
  nodeId?: string;
  isVisible?: boolean;
  selected?: boolean;
}

const props = withDefaults(defineProps<Props>(), {
  description: '',
  ctaText: 'Pesquisar categoria',
  nodeId: '',
  isVisible: false,
  selected: false
});

const emit = defineEmits<{ (e: 'primary'): void }>();
const slots = useSlots();
const cardRef: Ref<HTMLElement | null> = ref(null);

// Debug logging
onMounted(() => {
  console.log(`[CardOverlay] Mounted for node: ${props.nodeId}`, {
    label: props.label,
    isVisible: props.isVisible,
    hasIcon: !!slots.icon,
    hasDefaultSlot: !!slots.default,
    hasActionsSlot: !!slots.actions,
    timestamp: new Date().toISOString()
  });
});

// Watch for visibility changes
watch(() => props.isVisible, (newVal: boolean) => {
  console.log(`[CardOverlay] Visibility changed: ${newVal}`, {
    nodeId: props.nodeId,
    label: props.label,
    timestamp: new Date().toISOString()
  });
});

function onMouseEnter(event: MouseEvent) {
  console.log('[CardOverlay] Mouse enter:', {
    nodeId: props.nodeId,
    label: props.label,
    target: event.target,
    currentTarget: event.currentTarget,
    timestamp: new Date().toISOString()
  });
}

function onMouseLeave(event: MouseEvent) {
  console.log('[CardOverlay] Mouse leave:', {
    nodeId: props.nodeId,
    label: props.label,
    target: event.target,
    currentTarget: event.currentTarget,
    timestamp: new Date().toISOString()
  });
}

function onPrimary() {
  console.log('[CardOverlay] Primary action triggered:', {
    nodeId: props.nodeId,
    label: props.label,
    timestamp: new Date().toISOString()
  });
  emit('primary');
}
</script>
</file>

<file path="components/canvas/node/LightweightText.vue">
<template>
  <!-- Conteúdo lightweight SEM casco: deve ser usado DENTRO do BaseNodeShell -->
  <div
    class="w-full h-full flex items-center justify-center px-3"
    :class="{ 'pr-8': reserveRight }"
  >
    <span
      class="block text-sm leading-none truncate"
      :class="textClass"
      :title="label"
    >
      {{ label }}
    </span>
  </div>
</template>

<script setup lang="ts">
/**
 * LightweightText
 * - Apenas o conteúdo visual do estado "leve".
 * - Deve ser renderizado DENTRO do BaseNodeShell (no slot padrão).
 * - `reserveRight` deixa espaço à direita para o botão externo (+/-) quando existir.
 */
const props = withDefaults(
  defineProps<{
    label: string;
    /** Classe extra para o texto (ex.: 'text-white/90') */
    textClass?: string;
    /** Reserva espaço à direita para o conector externo */
    reserveRight?: boolean;
  }>(),
  {
    textClass: "text-white",
    reserveRight: false,
  }
);

const { label, textClass, reserveRight } = props;
</script>
</file>

<file path="types/nuxt-tailwindcss.d.ts">
// nuxt-app/types/nuxt-tailwindcss.d.ts
declare module "nuxt/schema" {
  interface NuxtConfig {
    tailwindcss?: {
      viewer?: boolean;
      cssPath?: string | false;
      configPath?: string;
      exposeConfig?: boolean;
      editorSupport?: boolean;
      // permite chaves extras do módulo
    } & Record<string, any>;
  }
  interface NuxtOptions extends NuxtConfig {}
}
export {};
</file>

<file path="app/app.vue">
<template>
  <div class="min-h-screen bg-gray-50">
    <NuxtLayout>
      <NuxtPage />
    </NuxtLayout>
  </div>
</template>

<style>
@import '~/assets/css/tailwind.css';
</style>
</file>

<file path="assets/css/tailwind.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
</file>

<file path="components/icon/CloseIcon.vue">
<template>
  <svg
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
    stroke="currentColor"
    class="w-6 h-6"
  >
    <path
      stroke-linecap="round"
      stroke-linejoin="round"
      stroke-width="2"
      d="M6 18L18 6M6 6l12 12"
    />
  </svg>
</template>
</file>

<file path="components/icon/HeartIcon.vue">
<template>
  <svg
    width="32"
    height="32"
    viewBox="0 0 32 32"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <path
      d="M26 18.096L16 28L12.1386 24.176M3.98263 13.3706C3.97149 11.9644 4.40529 10.5907 5.22199 9.44596C6.03869 8.3012 7.19647 7.444 8.52976 6.99696C9.86304 6.54992 11.3035 6.53593 12.6453 6.95699C13.987 7.37805 15.1612 8.2126 16 9.34129C16.5513 8.60798 17.2481 7.99638 18.0468 7.54476C18.8454 7.09314 19.7286 6.81122 20.6412 6.71665C21.5538 6.62208 22.4761 6.71689 23.3503 6.99514C24.2246 7.2734 25.032 7.72912 25.722 8.33377C26.4121 8.93843 26.9699 9.679 27.3605 10.5091C27.7512 11.3393 27.9663 12.2411 27.9924 13.1582C28.0185 14.0753 27.855 14.9879 27.5121 15.839C27.1693 16.69 26.6545 17.4611 26 18.104"
      stroke="#8E6CE4"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
    />
    <path
      d="M4 17.3333H6.66667L9.33333 21.3333L12 13.3333L13.3333 17.3333H17.3333"
      stroke="#8E6CE4"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
    />
  </svg>
</template>
</file>

<file path="components/icon/Logo.vue">
<template>
  <svg
    width="72"
    height="66"
    viewBox="0 0 72 66"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <path
      d="M43.0052 0.219238H62.2084C62.7981 0.219377 63.3413 0.551381 63.6029 1.08252L71.2904 16.3989C71.3272 16.4719 71.3547 16.548 71.3793 16.6245C71.3887 16.6537 71.3989 16.6827 71.4066 16.7124C71.4131 16.7376 71.418 16.7631 71.4232 16.7886C71.4284 16.8138 71.4329 16.8392 71.4369 16.8647C71.4416 16.8953 71.4458 16.9258 71.4486 16.9565C71.4509 16.9806 71.4523 17.0046 71.4535 17.0288C71.4548 17.0581 71.4558 17.0874 71.4554 17.1167C71.4552 17.1492 71.4529 17.1817 71.4506 17.2144C71.4491 17.2339 71.4488 17.2535 71.4467 17.2729C71.4293 17.4312 71.3881 17.5898 71.3197 17.7427L55.1332 53.7192C55.0613 53.883 54.9623 54.0385 54.8314 54.1753L44.1166 65.3003C43.8236 65.6049 43.4173 65.7769 42.9916 65.7769H18.1791C17.847 65.7769 17.5267 65.6714 17.2611 65.4761L6.77673 57.8472C6.77225 57.8439 6.76847 57.8397 6.76404 57.8364C6.72733 57.809 6.69158 57.7808 6.65759 57.7505C6.65224 57.7457 6.64724 57.7406 6.64197 57.7358C6.61168 57.7081 6.582 57.6799 6.55408 57.6499C6.54158 57.6366 6.5299 57.6226 6.51794 57.6089C6.49671 57.5844 6.4751 57.5604 6.45544 57.5347C6.44088 57.5157 6.42803 57.4956 6.41443 57.4761C6.39968 57.4549 6.38514 57.4336 6.37146 57.4116C6.35602 57.3869 6.34147 57.3618 6.32751 57.3364C6.31743 57.318 6.30756 57.2996 6.29822 57.2808C6.28051 57.2452 6.26426 57.2091 6.24939 57.1724C6.24594 57.1638 6.24195 57.1556 6.23865 57.147C6.22505 57.1116 6.21349 57.0757 6.20251 57.0396C6.19886 57.0275 6.19416 57.0156 6.1908 57.0034L0.600952 36.7378C0.487718 36.3239 0.550384 35.8784 0.772827 35.5112L17.5463 7.90576C17.7494 7.56987 18.0736 7.32373 18.4486 7.21436L42.5101 0.293457C42.5664 0.275395 42.6242 0.261179 42.683 0.249512C42.7226 0.241357 42.7625 0.235941 42.8021 0.230957C42.8122 0.229752 42.8222 0.227085 42.8324 0.226074C42.8902 0.219968 42.9479 0.218825 43.0052 0.219238ZM11.0677 57.105L18.6869 62.6519H42.3236L50.7953 53.856L34.9652 49.1382L11.0677 57.105ZM19.8939 10.0454L3.78943 36.5542H3.79236L8.76501 54.5806L33.9291 46.1938L49.9525 20.8237L42.1244 3.65479L19.8939 10.0454ZM52.6879 22.3374L37.3676 46.5913L52.8392 51.2036L67.2064 19.2651L52.6879 22.3374ZM52.6273 19.1587L67.5912 15.9927L61.2426 3.34424H45.4183L52.6273 19.1587Z"
      fill="white"
    />
  </svg>
</template>

<script>
export default {
  name: "Logo",
};
</script>
</file>

<file path="components/landing/FeaturesSection.vue">
<template>
  <section
    class="w-full flex flex-col items-center py-12 px-4 md:px-12 bg-[#18181B]"
  >
    <div class="max-w-4xl w-full text-center mb-12">
      <h2 class="text-3xl md:text-4xl font-bold text-white mb-4">
        Conheça nossos recursos
      </h2>
      <p class="text-lg md:text-xl text-gray-300">
        Descubra como nossas funcionalidades podem impulsionar sua experiência.
      </p>
    </div>
    <div class="w-full grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
      <div
        v-for="(feature, idx) in features"
        :key="idx"
        class="bg-[#23232A] rounded-xl p-8 flex flex-col items-center border border-[#353542] shadow-lg transition hover:scale-[1.03] hover:border-primary-500"
      >
        <div class="w-full flex justify-center mb-6">
          <div
            class="w-20 h-20 flex items-center justify-center bg-[#2d2d38] rounded-lg overflow-hidden border border-[#353542]"
          >
            <template v-if="feature.visual">
              <img
                v-if="isImage(feature.visual)"
                :src="feature.visual"
                alt="Visual da feature"
                class="object-contain w-full h-full"
                loading="lazy"
              />
              <video
                v-else-if="isVideo(feature.visual)"
                :src="feature.visual"
                class="object-contain w-full h-full"
                autoplay
                muted
                loop
                playsinline
              />
              <span v-else class="text-gray-500 text-xs">Visual</span>
            </template>
            <template v-else>
              <svg
                class="w-8 h-8 text-gray-500"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  d="M12 4v16m8-8H4"
                />
              </svg>
            </template>
          </div>
        </div>
        <h3 class="text-xl font-semibold text-white mb-2 text-center">
          {{ feature.title }}
        </h3>
        <p class="text-gray-300 text-base text-center">
          {{ feature.description }}
        </p>
      </div>
    </div>
  </section>
</template>

<script setup>
defineProps({
  features: {
    type: Array,
    required: true,
    default: () => [],
  },
});

function isImage(src) {
  return typeof src === "string" && /\.(jpe?g|png|gif|webp|svg)$/i.test(src);
}
function isVideo(src) {
  return typeof src === "string" && /\.(mp4|webm|ogg)$/i.test(src);
}
</script>

<style scoped>
/* Nenhum estilo adicional necessário, todo o layout usa Tailwind */
</style>
</file>

<file path="components/modals/BaseModal.vue">
<template>
  <Teleport :to="teleportTarget">
    <Transition name="modal-fade">
      <div
        v-if="isOpen"
        class="absolute inset-0 z-[30] flex items-center justify-center p-6 bg-black bg-opacity-70"
        @click.self="handleBackdropClick"
        role="dialog"
        aria-modal="true"
        :aria-labelledby="
          $slots.header && title ? 'base-modal-title-slot' : undefined
        "
      >
        <div
          :class="[
            'base-modal-container flex flex-col bg-[#171717] border border-[#343434] rounded-lg shadow-xl text-white overflow-hidden relative',
            modalSizeClass,
            modalContainerClass,
          ]"
          ref="modalContentRef"
        >
          <!-- Loading overlay -->
          <div
            v-if="isLoading"
            class="absolute inset-0 bg-[#171717] bg-opacity-90 flex flex-col items-center justify-center z-20 rounded-lg p-6"
          >
            <slot name="loading">
              <svg
                class="animate-spin h-8 w-8 text-blue-500"
                viewBox="0 0 24 24"
                fill="none"
              >
                <circle
                  class="opacity-25"
                  cx="12"
                  cy="12"
                  r="10"
                  stroke="currentColor"
                  stroke-width="4"
                ></circle>
                <path
                  class="opacity-75"
                  fill="currentColor"
                  d="M4 12a8 8 0 018-8v8z"
                ></path>
              </svg>
              <p class="mt-3 text-sm text-white">{{ loadingText }}</p>
            </slot>
          </div>

          <!-- Error overlay -->
          <div
            v-else-if="errorMessage && !isLoading"
            class="absolute inset-0 bg-[#171717] bg-opacity-95 flex flex-col items-center justify-center z-20 rounded-lg p-6 text-center"
          >
            <slot name="error">
              <div
                class="bg-red-900 border border-red-700 text-red-100 px-4 py-3 rounded relative max-w-md"
                role="alert"
              >
                <strong class="font-bold">Erro!</strong>
                <p class="block sm:inline">{{ errorMessage }}</p>
              </div>
            </slot>
          </div>

          <!-- Modal content (header, body, footer) -->
          <div
            :class="[
              'flex flex-col flex-1 min-h-0 h-full',
              modalSizeClass,
              contentWrapperClass,
            ]"
            v-if="!isLoading && !errorMessage"
          >
            <!-- Header: slot ou default -->
            <div
              v-if="$slots.header"
              class="base-modal-header flex-shrink-0"
              role="heading"
              aria-level="1"
            >
              <slot name="header"></slot>
            </div>
            <div
              v-else-if="!hideDefaultHeader"
              class="base-modal-header flex items-center justify-between px-6 py-4 border-b border-[#343434] flex-shrink-0"
              role="heading"
              aria-level="1"
            >
              <h2
                :id="title ? 'base-modal-title-slot' : undefined"
                class="text-lg font-semibold text-white truncate"
              >
                {{ title }}
              </h2>
              <button
                @click="closeModal"
                class="text-[#A0A0A0] hover:text-white transition-colors p-1 -mr-1"
                aria-label="Fechar modal"
              >
                <CloseIcon class="h-5 w-5" />
              </button>
            </div>

            <!-- Body (default slot) -->
            <div
              :class="[
                'base-modal-body h-full min-h-0 flex-1 overflow-y-auto',
                bodyClass,
              ]"
            >
              <slot></slot>
            </div>

            <!-- Footer: slot ou default -->
            <div v-if="$slots.footer" class="base-modal-footer flex-shrink-0">
              <slot name="footer"></slot>
            </div>
            <div
              v-else-if="!hideDefaultFooter"
              class="base-modal-footer flex justify-end items-center px-6 py-4 border-t border-[#343434] flex-shrink-0 gap-3 min-h-[68px]"
            ></div>
          </div>
        </div>
      </div>
    </Transition>
  </Teleport>
</template>

<script setup lang="ts">
import CloseIcon from "~/components/icon/CloseIcon.vue";

const props = defineProps({
  isOpen: { type: Boolean, required: true },
  title: { type: String, default: "" },
  size: { type: String, default: "viewport-fill" },
  closeOnBackdropClick: { type: Boolean, default: true },
  closeOnEsc: { type: Boolean, default: true },
  isLoading: { type: Boolean, default: false },
  loadingText: { type: String, default: "Carregando..." },
  errorMessage: { type: String, default: null },
  hideDefaultHeader: { type: Boolean, default: true },
  hideDefaultFooter: { type: Boolean, default: true },
  modalContainerClass: { type: String, default: "" },
  contentWrapperClass: { type: String, default: "" },
  bodyClass: { type: String, default: "" },
});

// Teleport target: use #modal-container if present, otherwise fallback to body
const teleportTarget = computed(() =>
  document.getElementById("modal-container") ? "#modal-container" : "body"
);

// Declare both 'close' and 'save' so Vue won't warn when @save is used upstream
const emit = defineEmits(["close", "save"]);

const modalContentRef = ref<HTMLElement | null>(null);

const modalSizeClass = computed(() => {
  switch (props.size) {
    case "sm":
      return "max-w-lg w-full min-h-[200px] max-h-[80vh]";
    case "md":
      return "max-w-xl w-full min-h-[300px] max-h-[80vh]";
    case "lg":
      return "max-w-3xl w-full min-h-[400px] max-h-[80vh]";
    case "xl":
      return "max-w-5xl w-full min-h-[500px] max-h-[85vh]";
    case "viewport-fill":
      // Preenche totalmente a área do wrapper (que já exclui SideNav/AgentSidebar),
      // sem ultrapassar para fora nem colar nas bordas internas
      return "w-full h-full max-w-full max-h-full min-h-[300px]";
    case "fullscreen":
      return "w-screen h-screen max-w-none max-h-none rounded-none !border-0";
    default:
      return "w-[95vw] h-[95vh] min-h-[300px]";
  }
});

// Modal close handlers
function closeModal() {
  emit("close");
}
function handleBackdropClick() {
  if (props.closeOnBackdropClick) closeModal();
}
function handleEscKey(event: KeyboardEvent) {
  if (props.isOpen && props.closeOnEsc && event.key === "Escape") closeModal();
}

// Use Nuxt's auto-imported lifecycle hooks
onMounted(() => {
  document.addEventListener("keydown", handleEscKey);
});

onUnmounted(() => {
  document.removeEventListener("keydown", handleEscKey);
});

// Focus trap: (simplificado, só volta foco pro modal se perder)
watch(
  () => props.isOpen,
  (open: boolean) => {
    if (open) setTimeout(() => modalContentRef.value?.focus(), 100);
  }
);
</script>

<style scoped>
.base-modal-container {
  max-height: 95vh;
  display: flex;

  flex-direction: column;
  position: relative;
}
.base-modal-body::-webkit-scrollbar {
  width: 6px;
}
.base-modal-body::-webkit-scrollbar-track {
  background: rgba(255, 255, 255, 0.05);
  border-radius: 3px;
}
.base-modal-body::-webkit-scrollbar-thumb {
  background-color: #4a5568;
  border-radius: 3px;
}
.base-modal-body::-webkit-scrollbar-thumb:hover {
  background-color: #718096;
}
.base-modal-body {
  scrollbar-width: thin;
  scrollbar-color: #4a5568 rgba(255, 255, 255, 0.05);
}

.modal-fade-enter-active,
.modal-fade-leave-active {
  transition: opacity 0.2s ease-in-out;
}
.modal-fade-enter-from,
.modal-fade-leave-to {
  opacity: 0;
}
.modal-fade-enter-active .base-modal-container,
.modal-fade-leave-active .base-modal-container {
  transition: transform 0.2s ease-in-out, opacity 0.2s ease-in-out;
}
.modal-fade-enter-from .base-modal-container,
.modal-fade-leave-to .base-modal-container {
  transform: scale(0.98) translateY(5px);
  opacity: 0;
}
</style>
</file>

<file path="components/ui/Button.vue">
<template>
  <button
    class="inline-flex items-center justify-center px-3 py-1.5 w-[130px] h-[40px] bg-[#8E6CE4] border-t-2 border-t-[#AB8FF1] rounded-sm text-white font-sans font-semibold text-normal leading-none tracking-[-0.12px] hover:opacity-90 transition-opacity"
    :class="[fullWidth ? 'w-full' : '']"
    :disabled="disabled"
    :type="type"
    @click="$emit('click', $event)"
  >
    <slot>Pesquisar nicho</slot>
  </button>
</template>

<script setup lang="ts">
const {
  type = "button",
  disabled = false,
  fullWidth = false,
} = defineProps<{
  type?: "button" | "submit" | "reset";
  disabled?: boolean;
  fullWidth?: boolean;
}>();

defineEmits<{
  (e: "click", event: MouseEvent): void;
}>();
</script>
</file>

<file path="layouts/blank.vue">
<!-- layouts/blank.vue -->
<template>
  <div>
    <!-- O <slot /> é o local onde o conteúdo da sua página (index.vue) será renderizado -->
    <slot />
  </div>
</template>
</file>

<file path="layouts/default.vue">
<!-- layouts/default.vue -->
<template>
  <div class="flex min-h-screen">
    <!-- Futuramente, o <SideNav /> entrará aqui -->
    <main class="flex-1">
      <!-- Mude de <NuxtPage /> para <slot /> -->
      <slot />
    </main>
  </div>
</template>
</file>

<file path="plugins/click-outside.ts">
// @ts-nocheck
import type { NuxtApp } from 'nuxt/app';
import vClickOutside from 'v-click-outside';

export default defineNuxtPlugin((nuxtApp: NuxtApp) => {
  nuxtApp.vueApp.use(vClickOutside);
});
</file>

<file path="plugins/supabase.client.ts">
import { defineNuxtPlugin } from "#imports";

// This plugin is intentionally left empty as we're using @nuxtjs/supabase module
// which provides the Supabase client automatically
// This prevents duplicate Supabase client initialization

export default defineNuxtPlugin(() => {
  // The @nuxtjs/supabase module automatically provides $supabase
  // No need to create another instance here
});
</file>

<file path="public/robots.txt">
User-Agent: *
Disallow:
</file>

<file path="types/components.d.ts">
// Type definitions for components
declare module '#components' {
  const LandingHeader: typeof import('../components/landing/LandingHeader.vue')['default']
  const HeroSection: typeof import('../components/landing/HeroSection.vue')['default']
  const FeaturesSection: typeof import('../components/landing/FeaturesSection.vue')['default']
  
  export {
    LandingHeader,
    HeroSection,
    FeaturesSection
  }
}

// Global component types
declare module 'vue' {
  interface GlobalComponents {
    LandingHeader: typeof import('../components/landing/LandingHeader.vue')['default']
    HeroSection: typeof import('../components/landing/HeroSection.vue')['default']
    FeaturesSection: typeof import('../components/landing/FeaturesSection.vue')['default']
  }
}

export {}
</file>

<file path="types/global.d.ts">
// Global type definitions for your project

// Type for the user from Supabase Auth
type User = {
  id: string;
  email?: string;
  // Add other user properties as needed
};

declare module '#app' {
  interface NuxtApp {
    $supabase: any; // You can replace 'any' with your Supabase client type
  }
}

declare module '@vue/runtime-core' {
  interface ComponentCustomProperties {
    $supabase: any; // You can replace 'any' with your Supabase client type
  }
}

// This tells TypeScript about the auto-imported functions
declare global {
  const defineNuxtRouteMiddleware: typeof import('nuxt/app')['defineNuxtRouteMiddleware'];
  const navigateTo: typeof import('nuxt/app')['navigateTo'];
  const useSupabaseClient: () => any; // Replace 'any' with your Supabase client type
  const useSupabaseUser: () => Ref<User | null>;
}
</file>

<file path="types/imports.d.ts">
// Type definitions for Nuxt auto-imports
declare module '#imports' {
  export * from '@nuxt/schema';
  export * from 'nuxt/app';
  export * from 'vue';
  export * from 'vue-router';
  export * from '#app';
  
  // Add Supabase client type
  export function useSupabaseClient(): any;
}

declare module '#app' {
  // Add navigateTo type
  export function navigateTo(route: string): Promise<void>;
  
  // Add defineNuxtRouteMiddleware type
  export function defineNuxtRouteMiddleware(middleware: (to: any, from: any) => any): any;
  interface NuxtApp {
    $supabase: any;
  }
}
</file>

<file path="types/nuxt-app.d.ts">
// Type definitions for Nuxt 3 app
declare module '#app' {
  interface NuxtApp {
    $supabase: any;
  }

  // Global middleware type
  function defineNuxtRouteMiddleware(
    middleware: (to: any, from: any) => Promise<void> | void
  );

  // Navigation helper
  function navigateTo(route: string, options?: { replace?: boolean }): Promise<void>;
}

declare module '@vue/runtime-core' {
  interface ComponentCustomProperties {
    $supabase: any;
  }
}

// Type definitions for auto-imports
declare module '#imports' {
  export * from 'vue';
  export * from 'vue-router';
  export * from '@nuxt/kit';
  export * from '@nuxt/schema';
  
  // Supabase
  export function useSupabaseClient(): any;
  export function useSupabaseUser(): any;
  
  // Nuxt composables
  export function useNuxtApp(): any;
  export function useRuntimeConfig(): any;
  export function useRoute(): any;
  export function useRouter(): any;
  export function useHead(meta: any): void;
  export function useSeoMeta(meta: any): void;
  
  // Other common composables
  export function ref<T>(value: T): { value: T };
  export function reactive<T extends object>(target: T): T;
  export function computed<T>(getter: () => T): { readonly value: T };
  export function watch<T>(source: () => T, callback: (newValue: T, oldValue: T) => void): () => void;
}
</file>

<file path="types/nuxt-config.d.ts">
// Type definitions for Nuxt config
declare module '@nuxt/schema' {
  interface NuxtConfig {
    // Nuxt Supabase module configuration
    supabase?: {
      url?: string
      key?: string
      serviceKey?: string
      redirect?: boolean
      redirectOptions?: {
        login: string
        callback: string
        exclude?: string[]
        cookieRedirect?: boolean
      }
      cookieOptions?: {
        name?: string
        lifetime?: number
        domain?: string
        path?: string
        sameSite?: 'lax' | 'strict' | 'none'
      }
      clientOptions?: {
        auth?: {
          flowType?: 'implicit' | 'pkce'
          detectSessionInUrl?: boolean
          persistSession?: boolean
          autoRefreshToken?: boolean
        }
      }
    }
  }
}

export {}
</file>

<file path="types/supabase.d.ts">
import type { SupabaseClient } from '@supabase/supabase-js'

type Tables = {
  // Define your database tables here
  // Example:
  // todos: {
  //   Row: { id: string; created_at: string; title: string; completed: boolean }
  //   Insert: { id?: string; created_at?: string; title: string; completed?: boolean }
  //   Update: { id?: string; created_at?: string; title?: string; completed?: boolean }
  // }
}

type Database = Tables

declare module '#app' {
  interface NuxtApp {
    $supabase: SupabaseClient<Database>
  }
}

declare module '@vue/runtime-core' {
  interface ComponentCustomProperties {
    $supabase: SupabaseClient<Database>
  }
}

export {}
</file>

<file path="types/supabase.ts">
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[];

export interface Database {
  public: {
    Tables: {
      // Vamos adicionar as tabelas aqui no futuro
    };
    Views: {
      [_ in never]: never;
    };
    Functions: {
      [_ in never]: never;
    };
    Enums: {
      [_ in never]: never;
    };
    CompositeTypes: {
      [_ in never]: never;
    };
  };
}
</file>

<file path="types/tailwind.d.ts">
// This file provides TypeScript support for Tailwind CSS
declare module 'tailwindcss' {
  // Add type definitions here if needed
}

declare module '@nuxtjs/tailwindcss' {
  // Add type definitions here if needed
}
</file>

<file path="types/v-click-outside.d.ts">
declare module 'v-click-outside' {
  import { DirectiveFunction } from 'vue';
  
  const vClickOutside: {
    install: (app: any) => void;
  };
  
  export default vClickOutside;
}
</file>

<file path="types/vue-flow-controls.d.ts">
// Type definitions for @vue-flow/controls

declare module '@vue-flow/controls' {
  import { DefineComponent } from 'vue';
  
  export const Controls: DefineComponent<{
    showZoom?: boolean;
    showFitView?: boolean;
    showInteractive?: boolean;
    position?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
  }>;
  
  export const ControlButton: DefineComponent<{
    class?: string;
    style?: string | Record<string, any>;
    title?: string;
    disabled?: boolean;
  }>;
}
</file>

<file path=".env.example">
# Supabase Configuration
SUPABASE_URL=your-supabase-url
SUPABASE_ANON_KEY=your-supabase-anon-key

# Other environment variables
NODE_ENV=development

# Optional: Service role key (only for server-side operations)
# SUPABASE_SERVICE_KEY=your-supabase-service-key
</file>

<file path=".gitignore">
# Nuxt dev/build outputs
.output
.data
.nuxt
.nitro
.cache
dist

# Node dependencies
node_modules

# Logs
logs
*.log

# Misc
.DS_Store
.fleet
.idea

# Local env files
.env
.env.*
!.env.example
</file>

<file path="components.d.ts">
// Type definitions for Vue components
declare module '*.vue' {
  import type { DefineComponent } from 'vue'
  const component: DefineComponent<{}, {}, any>
  export default component
}

// Component type declarations
declare module '#app' {
  interface NuxtApp {
    // App-level types
  }
  
  interface PageMeta {
    layout?: string
  }
}

// Global component types
declare module 'vue' {
  interface GlobalComponents {
    LandingHeader: typeof import('./components/landing/LandingHeader.vue')['default']
    HeroSection: typeof import('./components/landing/HeroSection.vue')['default']
    FeaturesSection: typeof import('./components/landing/FeaturesSection.vue')['default']
  }
}

// Type declarations for Nuxt auto-imports
declare module '#imports' {
  export const useSeoMeta: typeof import('@unhead/vue')['useSeoMeta']
  export const ref: typeof import('vue')['ref']
}

declare module '#app' {
  interface PageMeta {
    layout?: string
  }
  
  function definePageMeta(meta: PageMeta): void
}

export {}
</file>

<file path="nuxt.tsconfig.json">
{
  "extends": "./.nuxt/tsconfig.json"
}
</file>

<file path="README.md">
# Nuxt Minimal Starter

Look at the [Nuxt documentation](https://nuxt.com/docs/getting-started/introduction) to learn more.

## Setup

Make sure to install dependencies:

```bash
# npm
npm install

# pnpm
pnpm install

# yarn
yarn install

# bun
bun install
```

## Development Server

Start the development server on `http://localhost:3000`:

```bash
# npm
npm run dev

# pnpm
pnpm dev

# yarn
yarn dev

# bun
bun run dev
```

## Production

Build the application for production:

```bash
# npm
npm run build

# pnpm
pnpm build

# yarn
yarn build

# bun
bun run build
```

Locally preview production build:

```bash
# npm
npm run preview

# pnpm
pnpm preview

# yarn
yarn preview

# bun
bun run preview
```

Check out the [deployment documentation](https://nuxt.com/docs/getting-started/deployment) for more information.
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./app.vue",
    "./app/**/*.vue",
    "./components/**/*.{js,vue,ts}",
    "./layouts/**/*.vue",
    "./pages/**/*.vue",
    "./plugins/**/*.{js,ts}",
    "./error.vue"
  ],
  theme: {
    extend: {
      colors: {
        dark: '#171717',
      }
    },
  },
  plugins: [],
  darkMode: 'class',
  corePlugins: {
    preflight: true,
  },
  future: {
    hoverOnlyWhenSupported: true,
  },
  important: true
}
</file>

<file path="components/landing/HeroSection.vue">
<template>
  <section class="bg-[#17171C] w-full py-16 md:py-24">
    <div
      class="max-w-5xl font-light mx-auto flex flex-col md:flex-row items-center justify-between px-4 gap-10"
    >
      <!-- Left: Headline, Subheadline, CTA -->
      <div class="flex-1 flex flex-col md:items-start text-center md:text-left">
        <h1 class="text-3xl md:text-5xl font-bold text-white mb-4">
          {{ headline }}
        </h1>
        <p class="text-lg md:text-2xl text-white mb-8 font-medium">
          {{ subheadline }}
        </p>
        <NuxtLink
          to="/register"
          class="w-full md:w-auto inline-block px-8 py-3 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-lg shadow transition text-center"
        >
          {{ ctaText || "Comece a usar de graça" }}
        </NuxtLink>
      </div>
      <!-- Right: Slot for image/visual -->

      <div
        class="flex-1 flex justify-center md:justify-end w-full mt-10 md:mt-0"
      >
        <img src="~/assets/images/hero-img.png" alt="Hero Image" />
      </div>
    </div>
  </section>
</template>

<script setup lang="ts">
defineProps<{
  headline: string;
  subheadline: string;
  ctaText?: string;
}>();
</script>
</file>

<file path="components/landing/LandingHeader.vue">
<template>
  <header
    class="w-full bg-[#17171C] px-6 py-4 flex items-center justify-between shadow-sm border-b border-[#232323]"
  >
    <NuxtLink to="/" class="flex items-center gap-2">
      <!-- Substitua pelo componente/logo real caso exista -->
      <Logo class="w-8 h-8" />
      <span class="text-xl font-light text-white">Gold Miner</span>
    </NuxtLink>
    <NuxtLink
      to="/register"
      class="btn btn-primary bg-blue-600 text-white rounded-lg px-5 py-2 font-semibold hover:bg-blue-700 transition"
    >
      Comece a usar de graça
    </NuxtLink>
  </header>
</template>

<script setup>
import Logo from "~/components/icon/Logo.vue";
// Nenhuma lógica específica necessária para este header simples
</script>
</file>

<file path="components/SearchCard.vue">
<template>
  <div class="flex flex-col items-start p-3 gap-2.5 w-full bg-[#17171C] shadow-md rounded-lg">
    <!-- Header -->
    <div class="w-full flex flex-row items-center">
      <h3 class="text-[#DAD7DE] text-sm font-semibold leading-5">
        Busque por um mercado ou nicho
      </h3>
    </div>
    
    <!-- Search Input -->
    <div class="w-full">
      <div class="relative flex items-center w-full">
        <input
          type="text"
          :placeholder="placeholder"
          :value="modelValue"
          @input="handleInput"
          @keyup.enter="$emit('search', searchQuery)"
          class="w-full h-9 px-2.5 py-1.5 bg-[#292932] rounded text-[#DAD7DE] text-sm placeholder:text-[rgba(218,215,222,0.3)] focus:outline-none focus:ring-1 focus:ring-[#8E6CE4]"
        />
        <button
          v-if="modelValue"
          @click="clearSearch"
          class="absolute right-2 text-[#DAD7DE] hover:text-white"
        >
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M18 6L6 18M6 6L18 18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
      </div>
    </div>
    
    <!-- Results Slot -->
    <div v-if="$slots.results" class="w-full">
      <slot name="results"></slot>
    </div>
  </div>
</template>

<script setup lang="ts">
const props = defineProps({
  placeholder: {
    type: String,
    default: "ex: 'saúde para idosos', 'produtividade'"
  },
  modelValue: {
    type: String,
    default: ''
  }
})

const emit = defineEmits(['update:modelValue', 'search'])

const searchQuery = ref(props.modelValue)

const handleInput = (event: Event) => {
  const value = (event.target as HTMLInputElement).value
  searchQuery.value = value
  emit('update:modelValue', value)
  emit('search', value)
}

const clearSearch = () => {
  searchQuery.value = ''
  emit('update:modelValue', '')
  emit('search', '')
}

// Watch for external modelValue changes
watch(() => props.modelValue, (newValue: string) => {
  if (newValue !== searchQuery.value) {
    searchQuery.value = newValue
  }
})
</script>
</file>

<file path="composables/useMindMapLayout.ts">
import type { Node, Edge, XYPosition } from "@vue-flow/core";

// Semantic levels supported when present in node.data.level
export type NodeLevel =
  | "CoreMarket"
  | "Category"
  | "Subcategory"
  | "Niche"
  | "SubNiche";

const LEVEL_ORDER: Record<NodeLevel, number> = {
  CoreMarket: 0,
  Category: 1,
  Subcategory: 2,
  Niche: 3,
  SubNiche: 4,
};

type LayoutOpts = {
  rootId: string;
  /** Base horizontal distance between columns (used if no levelGaps provided) */
  levelGap?: number;
  /** Base vertical distance between siblings (used if no rowGaps provided) */
  rowGap?: number;
  /** Where to place the root */
  center?: XYPosition;
  /** Optional per-column horizontal gaps; index == column */
  levelGaps?: number[];
  /** Optional per-column vertical gaps; index == column */
  rowGaps?: number[];
};

export function layoutMindMap(
  nodes: Node[],
  edges: Edge[],
  opts: LayoutOpts
): Node[] {
  const baseLevelGap = opts.levelGap ?? 280;
  const baseRowGap = opts.rowGap ?? 100;
  const center = opts.center ?? { x: 200, y: 200 };
  const levelGaps = opts.levelGaps ?? [];
  const rowGaps = opts.rowGaps ?? [];

  const getLevelGap = (col: number) => levelGaps[col] ?? baseLevelGap;
  const getRowGap = (col: number) => rowGaps[col] ?? baseRowGap;

  // Quick indices
  const nodeById = new Map<string, Node>();
  nodes.forEach((n) => nodeById.set(n.id, n));

  const children = new Map<string, string[]>();
  const parentOf = new Map<string, string>();
  edges.forEach((e) => {
    if (!children.has(e.source)) children.set(e.source, []);
    children.get(e.source)!.push(e.target);
    parentOf.set(e.target, e.source);
  });

  // BFS fallback levels starting at root
  const bfsLevel = new Map<string, number>();
  const q: Array<[string, number]> = [[opts.rootId, 0]];
  const seen = new Set<string>();
  while (q.length) {
    const [id, lvl] = q.shift()!;
    if (seen.has(id)) continue;
    seen.add(id);
    bfsLevel.set(id, lvl);
    const kids = children.get(id) ?? [];
    for (const kid of kids) q.push([kid, lvl + 1]);
  }

  // Column by semantic level when available, otherwise BFS
  const colOf = (id: string): number => {
    const n = nodeById.get(id);
    const lvlName = (n?.data as any)?.level as NodeLevel | undefined;
    if (lvlName && lvlName in LEVEL_ORDER) return LEVEL_ORDER[lvlName];
    return bfsLevel.get(id) ?? 0;
  };

  // Precompute cumulative X offsets per column
  const maxCol = Math.max(
    0,
    ...nodes.map((n) => {
      const lvlName = (n.data as any)?.level as NodeLevel | undefined;
      if (lvlName && lvlName in LEVEL_ORDER) return LEVEL_ORDER[lvlName];
      return bfsLevel.get(n.id) ?? 0;
    })
  );
  const colOffsetX: number[] = new Array(maxCol + 1).fill(0);
  for (let c = 1; c <= maxCol; c++) {
    colOffsetX[c] = colOffsetX[c - 1] + getLevelGap(c - 1);
  }

  // Position map we will fill
  const positioned = new Map<string, XYPosition>();

  // Place root so its visual center aligns to `center.y`
  const rootNode = nodeById.get(opts.rootId) as any;
  const rootLevel: string | undefined = rootNode?.data?.level;
  const fallbackRootH = rootLevel === "CoreMarket" ? 88 : 24;
  const rootH: number = rootNode?.dimensions?.height ?? fallbackRootH;
  positioned.set(opts.rootId, { x: center.x, y: center.y - rootH / 2 });

  // Walk columns from 1..max, group children by parent and stack around parent.y
  for (let c = 1; c <= maxCol; c++) {
    // collect all nodes that belong to column c
    const idsAtCol = nodes.map((n) => n.id).filter((id) => colOf(id) === c);

    if (!idsAtCol.length) continue;

    // group by parent to keep siblings together
    const groups = new Map<string, string[]>();
    for (const id of idsAtCol) {
      const p = parentOf.get(id);
      if (!p) continue;
      if (!groups.has(p)) groups.set(p, []);
      groups.get(p)!.push(id);
    }

    // position each group near its parent
    for (const [parentId, group] of groups) {
      // parent might not be in same column; ensure we have its position
      const pPos = positioned.get(parentId) ?? {
        x: center.x + colOffsetX[colOf(parentId)],
        y: center.y,
      };
      positioned.set(parentId, pPos);

      const x = center.x + colOffsetX[c];
      const gapY = getRowGap(c);
      const total = (group.length - 1) * gapY;

      // Parent visual midline
      const parentNode = nodeById.get(parentId) as any;
      const parentLevel: string | undefined = parentNode?.data?.level;
      // Fallback heights by level to approximate visual center when dimensions are not yet available
      const fallbackParentH =
        parentLevel === "CoreMarket"
          ? 88
          : /* Category / Subcategory / Niche / SubNiche (lightweight text) */ 24;

      const parentH: number = parentNode?.dimensions?.height ?? fallbackParentH;
      const parentCenterY = pPos.y + parentH / 2;

      // Provisional positions using tops spaced by gapY and a generic child height
      const firstChild = nodeById.get(group[0]) as any;
      const approxChildH: number = firstChild?.dimensions?.height ?? 24;
      const startY = parentCenterY - total / 2 - approxChildH / 2;

      // Stage provisional positions in an array to compute visual bbox
      const provisional = group.map((id, idx) => ({
        id,
        x,
        y: startY + idx * gapY,
      }));

      // Compute group visual bbox using measured heights when available
      let minY = Number.POSITIVE_INFINITY;
      let maxY = Number.NEGATIVE_INFINITY;
      const heights = new Map<string, number>();
      for (const { id, y } of provisional) {
        const child = nodeById.get(id) as any;
        const h = child?.dimensions?.height ?? approxChildH;
        heights.set(id, h);
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y + h);
      }

      // Center group bbox midline to parent's center
      const groupCenterY = (minY + maxY) / 2;
      const deltaY = parentCenterY - groupCenterY;

      // Persist final positions (shifted by deltaY)
      for (const { id, x, y } of provisional) {
        const finalY = y + deltaY;
        positioned.set(id, { x, y: finalY });
      }
    }
  }

  // Ensure any nodes without parents (or ungrouped) still get a position by their column, stacking progressively
  const fallbackCountPerCol = new Map<number, number>();
  for (const n of nodes) {
    if (positioned.has(n.id)) continue;
    const c = colOf(n.id);
    const x = center.x + colOffsetX[c];
    const i = fallbackCountPerCol.get(c) ?? 0;
    const y = center.y + (i - 0.5) * getRowGap(c);
    fallbackCountPerCol.set(c, i + 1);
    positioned.set(n.id, { x, y });
  }

  // Return nodes with position applied
  return nodes.map((n) => {
    const p = positioned.get(n.id);
    return p ? { ...n, position: p, draggable: false } : n;
  });
}
</file>

<file path="middleware/auth.global.ts">
// Import directly from Nuxt 3 packages
import { navigateTo, defineNuxtRouteMiddleware } from '#app';
import { useSupabaseClient } from '#imports';

export default defineNuxtRouteMiddleware(async (to, _from) => {

  // Páginas que não exigem login
  const publicPages = ["/", "/login", "/register"];

  if (publicPages.includes(to.path)) {
    return; // Permite o acesso a páginas públicas
  }

  const supabase = useSupabaseClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user && !publicPages.includes(to.path)) {
    // Se não há usuário e a página é privada, redireciona para o login
    return navigateTo("/login");
  } else if (
    user &&
    (to.path === "/login" || to.path === "/register" || to.path === "/")
  ) {
    // Se há usuário e ele tenta acessar o login/cadastro/landing, redireciona para o app
    return navigateTo("/app");
  }
});
</file>

<file path="pages/index.vue">
<template>
  <div class="min-h-screen bg-[#17171C] text-white">
    <LandingHeader />
    <main class="w-full mx-auto px-4 py-10">
      <HeroSection
        headline="Pare de procurar por ideias. Comece a minerar ouro."
        subheadline="O Gold Miner é um framework visual que usa IA para descobrir nichos de mercado promissores, validar a demanda e gerar sua primeira landing page. Tudo em menos de uma hora."
        ctaText="Encontre sua ideia de ouro de graça"
      />
      <FeaturesSection :features="productFeatures" />
    </main>
  </div>
</template>

<script setup lang="ts">
// Define features data with TypeScript type
interface Feature {
  title: string;
  description: string;
  icon?: string;
}

const productFeatures: Feature[] = [
  {
    title: "Análise de Mercado",
    description:
      "Identifique oportunidades de mercado com base em dados reais de busca e concorrência.",
    icon: "📊",
  },
  {
    title: "Validação de Ideias",
    description:
      "Teste a viabilidade do seu negócio antes de investir tempo e dinheiro.",
    icon: "✅",
  },
  {
    title: "Geração de Conteúdo",
    description:
      "Crie conteúdo otimizado para seu público-alvo com a ajuda de IA.",
    icon: "✍️",
  },
];

// Page metadata
definePageMeta({
  layout: "default",
});
</script>
</file>

<file path="types/nuxt.d.ts">
import type { SupabaseClient, User } from '@supabase/supabase-js';
import type { Config } from 'tailwindcss';
import type { H3Event } from 'h3';
import type { RouteLocationNormalized } from 'vue-router';

type Tables = {
  // Define your database tables here
  // Example:
  // todos: {
  //   Row: { id: string; created_at: string; title: string; completed: boolean }
  //   Insert: { id?: string; created_at?: string; title: string; completed?: boolean }
  //   Update: { id?: string; created_at?: string; title?: string; completed?: boolean }
  // }
}

type Database = Tables

declare module '#app' {
  interface NuxtApp {
    $supabase: SupabaseClient<Database>
  }
  
  // Add global middleware types
  function defineNuxtRouteMiddleware(
    middleware: (to: RouteLocationNormalized, from: RouteLocationNormalized) => Promise<void> | void
  ): void
  
  function navigateTo(
    to: string,
    options?: { replace?: boolean; redirectCode?: number }
  ): Promise<void> | void
  
  function useSupabaseClient(): SupabaseClient<Database>
  function useSupabaseUser(): any // Adjust the type according to your user type
}

declare module '@vue/runtime-core' {
  interface ComponentCustomProperties {
    $supabase: SupabaseClient<Database>
  }
}

// Extend Nuxt configuration with Tailwind CSS module
declare module 'nuxt/schema' {
  interface NuxtConfig {
    tailwindcss?: {
      config?: Partial<Config>
      cssPath?: string
      configPath?: string
      exposeConfig?: boolean
      injectPosition?: number
      viewer?: boolean
    }
  }
}

// This is needed for the $tailwind property
declare module '@nuxt/schema' {
  interface NuxtConfig {
    tailwindcss?: {
      config?: Partial<Config>
      cssPath?: string
      configPath?: string
      exposeConfig?: boolean
      injectPosition?: number
      viewer?: boolean
    }
  }
}

// Type definitions for Nuxt auto-imports
declare global {
  // Nuxt auto-imports
  const definePageMeta: typeof import('nuxt/app')['definePageMeta']
  const useHead: typeof import('@unhead/vue')['useHead']
  const useSeoMeta: typeof import('@unhead/vue')['useSeoMeta']
  const useNuxtApp: typeof import('nuxt/app')['useNuxtApp']
  const ref: typeof import('vue')['ref']
  const computed: typeof import('vue')['computed']
  const onMounted: typeof import('vue')['onMounted']
  const onUnmounted: typeof import('vue')['onUnmounted']
  const watch: typeof import('vue')['watch']
  const useRouter: typeof import('vue-router')['useRouter']
  const useRoute: typeof import('vue-router')['useRoute']
  
  // Supabase
  const useSupabaseClient: () => SupabaseClient<Database>
  const useSupabaseUser: () => any // You can type this more specifically if needed
}

export {}
</file>

<file path="tsconfig.json">
// Base TypeScript configuration for Nuxt 3
{
  // Extend from the Nuxt recommended tsconfig
  "extends": "./.nuxt/tsconfig.json",

  // Compiler options
  "compilerOptions": {
    // Type checking
    "types": ["vue", "vite/client", "nuxt/schema", "@pinia/nuxt"],
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "noImplicitThis": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "allowJs": true,
    "noEmit": true,

    // Module resolution
    "baseUrl": ".",
    "moduleResolution": "bundler",
    "module": "esnext",
    "target": "ESNext",
    "jsx": "preserve",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "lib": ["ESNext", "DOM", "DOM.Iterable"],

    // Path aliases
    "paths": {
      "~/*": ["./*"],
      "@/*": ["./*"]
    }
  },

  // Include these files for type checking
  "include": [
    ".nuxt/nuxt.d.ts",
    "components/**/*",
    "composables/**/*",
    "layouts/**/*",
    "middleware/**/*",
    "pages/**/*",
    "plugins/**/*",
    "app.vue",
    "error.vue",
    "types/**/*.d.ts",
    "types/**/*.ts"
  ],

  // Exclude these files from type checking
  "exclude": ["node_modules", ".nuxt", ".output", "dist"]
}
</file>

<file path="pages/login.vue">
<template>
  <div
    class="flex flex-col items-center justify-center min-h-screen bg-[#17171C]"
  >
    <div
      class="bg-[#17171C] border border-[#47464B] p-8 rounded-lg shadow-md w-full max-w-sm"
    >
      <div class="flex items-center justify-center mb-6">
        <Logo class="w-8 h-8" />
        <h2 class="text-xl ml-1 font-light text-white">Gold Miner</h2>
      </div>

      <form @submit.prevent="handleLogin">
        <div class="mb-4">
          <label class="block text-white mb-2 font-light" for="email"
            >E-mail</label
          >
          <input
            v-model="email"
            id="email"
            type="email"
            autocomplete="email"
            required
            class="w-full px-3 py-2 border border-[#47464B] rounded text-white bg-[#2C2B30] autofill-bg"
          />
        </div>
        <div class="mb-6">
          <label class="block text-white mb-2 font-light" for="password"
            >Senha</label
          >
          <input
            v-model="password"
            id="password"
            type="password"
            autocomplete="current-password"
            required
            class="w-full px-3 py-2 border border-[#47464B] rounded text-white bg-[#2C2B30] autofill-bg"
          />
        </div>
        <div class="mt-4">
          <Button type="submit" :disabled="isLoading" class="w-full">
            <template v-if="!isLoading">Entrar</template>
            <template v-else>
              <svg
                class="animate-spin h-5 w-5 text-white"
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 24 24"
              >
                <path
                  class="opacity-75"
                  fill="currentColor"
                  d="M12 2a10 10 0 100 20 10 10 0 000-20zm1 18V4a8 8 0 010 16z"
                />
              </svg>
              <span class="ml-2">Entrando...</span>
            </template>
          </Button>
        </div>
        <p v-if="error" class="mt-4 text-red-600 text-center">{{ error }}</p>
      </form>
      <p class="block mt-6 text-sm text-center text-white">
        Não tem uma conta?
        <NuxtLink
          to="/register"
          class="mt-6 text-sm text-blue-600 hover:underline text-center"
        >
          Cadastre-se
        </NuxtLink>
      </p>
    </div>
  </div>
</template>

<script setup lang="ts">
// Components
import Button from "~/components/ui/Button.vue";
import Logo from "~/components/icon/Logo.vue";

// State
const email = ref("");
const password = ref("");
const error = ref("");
const isLoading = ref(false);

// Composable
const router = useRouter();
const supabase = useSupabaseClient();

// Nuxt 3 auto-imports these:
// - ref, useRouter, useSupabaseClient, NuxtLink

async function handleLogin() {
  isLoading.value = true;
  error.value = "";
  const { error: loginError } = await supabase.auth.signInWithPassword({
    email: email.value,
    password: password.value,
  });

  if (loginError) {
    error.value = "E-mail ou senha inválidos.";
    isLoading.value = false;
    return;
  } else {
    // Aguarda tarefas carregarem, passando o client
    await router.replace("/app");

    isLoading.value = false;
  }
}
</script>

<style scoped>
/* Autofill styles */
:deep(input.autofill-bg:-webkit-autofill),
:deep(input.autofill-bg:-webkit-autofill:hover),
:deep(input.autofill-bg:-webkit-autofill:focus),
:deep(input.autofill-bg:-webkit-autofill:active) {
  -webkit-box-shadow: 0 0 0 30px #2c2b30 inset !important;
  -webkit-text-fill-color: white !important;
  transition: background-color 5000s ease-in-out 0s;
}

body {
  background: #f9fafb;
}
</style>
</file>

<file path="pages/register.vue">
<script setup>
definePageMeta({ layout: "blank" });
import { ref } from "vue";
import { useRouter } from "vue-router";
import Logo from "~/components/icon/Logo.vue";
import Button from '~/components/ui/Button.vue';

const supabase = useSupabaseClient();
const router = useRouter();

const email = ref("");
const password = ref("");
const confirmPassword = ref("");
const errorMessage = ref("");
const successMessage = ref("");
const loading = ref(false);

const handleRegister = async () => {
  errorMessage.value = "";
  successMessage.value = "";
  if (password.value !== confirmPassword.value) {
    errorMessage.value = "As senhas não coincidem.";
    return;
  }
  loading.value = true;
  const { error } = await supabase.auth.signUp({
    email: email.value,
    password: password.value,
  });
  loading.value = false;
  if (error) {
    errorMessage.value = error.message;
  } else {
    successMessage.value =
      "Cadastro realizado com sucesso! Verifique seu email.";
    setTimeout(() => {
      router.push("/login");
    }, 2000);
  }
};
</script>

<style scoped>
/* Autofill styles */
:deep(input.autofill-bg:-webkit-autofill),
:deep(input.autofill-bg:-webkit-autofill:hover),
:deep(input.autofill-bg:-webkit-autofill:focus),
:deep(input.autofill-bg:-webkit-autofill:active) {
  -webkit-box-shadow: 0 0 0 30px #2c2b30 inset !important;
  -webkit-text-fill-color: white !important;
  transition: background-color 5000s ease-in-out 0s;
}
</style>

<template>
  <div
    class="flex flex-col items-center justify-center min-h-screen bg-[#17171C]"
  >
    <div
      class="bg-[#17171C] border border-[#47464B] p-8 rounded-lg shadow-md w-full max-w-sm"
    >
      <div class="flex items-center justify-center mb-6">
        <Logo class="w-8 h-8" />
        <h2 class="text-xl ml-1 font-light text-white">Gold Miner</h2>
      </div>
      <form @submit.prevent="handleRegister" class="space-y-4">
        <div>
          <label class="block text-white mb-2 font-light" for="email"
            >Email</label
          >
          <input
            id="email"
            v-model="email"
            type="email"
            autocomplete="email"
            class="w-full px-3 py-2 border border-[#47464B] rounded text-white bg-[#2C2B30] focus:bg-[#2C2B30] autofill-bg"
            required
          />
        </div>
        <div>
          <label class="block text-white mb-2 font-light" for="password"
            >Senha</label
          >
          <input
            id="password"
            v-model="password"
            type="password"
            autocomplete="new-password"
            class="w-full px-3 py-2 border border-[#47464B] rounded text-white bg-[#2C2B30] autofill-bg"
            required
          />
        </div>
        <div>
          <label class="block text-white mb-2 font-light" for="confirmPassword"
            >Confirmar senha</label
          >
          <input
            id="confirmPassword"
            v-model="confirmPassword"
            type="password"
            autocomplete="new-password"
            class="w-full px-3 py-2 border border-[#47464B] rounded text-white bg-[#2C2B30] autofill-bg"
            required
          />
        </div>
        <div v-if="errorMessage" class="mt-4 text-red-600 text-center">
          {{ errorMessage }}
        </div>
        <div v-if="successMessage" class="mt-4 text-green-500 text-center">
          {{ successMessage }}
        </div>
        <Button
          type="submit"
          :disabled="loading"
          class="w-full"
        >
          {{ loading ? 'Cadastrando...' : 'Cadastrar' }}
        </Button>
      </form>
      <p class="block mt-6 text-sm text-center text-white">
        Já tem uma conta?
        <NuxtLink to="/login" class="text-blue-600 hover:underline"
          >Entrar</NuxtLink
        >
      </p>
    </div>
  </div>
</template>
</file>

<file path="stores/mindMapStore.ts">
import { defineStore } from "pinia";
import type { Node, Edge } from "@vue-flow/core";
import { layoutMindMap } from "~/composables/useMindMapLayout";

type NodeLevel =
  | "CoreMarket"
  | "Category"
  | "Subcategory"
  | "Niche"
  | "SubNiche";

export interface MindMapNode extends Node {
  parentNode?: string;
  data: {
    label: string;
    level: NodeLevel;
    iconName?: string;
    children?: MindMapNode[];
    isExpanded?: boolean;
    edgeLabel?: string;
  };
}

// Start with all nodes collapsed by default
const initialNodes: MindMapNode[] = [
  {
    id: "health",
    type: "custom",
    data: {
      label: "Saúde",
      level: "CoreMarket",
      iconName: "heart",
      isExpanded: false,
      children: [
        {
          id: "nutrition",
          type: "custom",
          data: {
            label: "Nutrição e dieta",
            level: "Category",
            isExpanded: false,
            edgeLabel: "Nutrição e dieta",
            children: [
              {
                id: "diets",
                type: "custom",
                data: {
                  label: "Dietas",
                  level: "Subcategory",
                  isExpanded: false,
                  edgeLabel: "Dietas",
                  children: [
                    {
                      id: "low-carb",
                      type: "custom",
                      data: {
                        label: "Low-carb",
                        level: "Niche",
                        isExpanded: false,
                        edgeLabel: "Low-carb",
                        children: [
                          {
                            id: "low-carb-diabeticos",
                            type: "custom",
                            data: {
                              label: "Receitas low-carb para diabéticos",
                              level: "SubNiche",
                              isExpanded: false,
                              edgeLabel: "Receitas low-carb p/ diabéticos",
                              children: [],
                            },
                            position: { x: 0, y: 0 },
                          },
                        ],
                      },
                      position: { x: 0, y: 0 },
                    },
                    {
                      id: "plant-based",
                      type: "custom",
                      data: {
                        label: "Plant-based",
                        level: "Niche",
                        isExpanded: false,
                        edgeLabel: "Plant-based",
                        children: [
                          {
                            id: "cardapios-economicos",
                            type: "custom",
                            data: {
                              label: "Cardápios semanais econômicos",
                              level: "SubNiche",
                              isExpanded: false,
                              edgeLabel: "Cardápios econômicos",
                              children: [],
                            },
                            position: { x: 0, y: 0 },
                          },
                        ],
                      },
                      position: { x: 0, y: 0 },
                    },
                  ],
                },
                position: { x: 0, y: 0 },
              },
              {
                id: "supplementation",
                type: "custom",
                data: {
                  label: "Suplementação",
                  level: "Subcategory",
                  isExpanded: false,
                  edgeLabel: "Suplementação",
                  children: [
                    {
                      id: "performance",
                      type: "custom",
                      data: {
                        label: "Performance esportiva",
                        level: "Niche",
                        isExpanded: false,
                        edgeLabel: "Performance esportiva",
                        children: [
                          {
                            id: "creatina-iniciantes",
                            type: "custom",
                            data: {
                              label: "Creatina para iniciantes",
                              level: "SubNiche",
                              isExpanded: false,
                              edgeLabel: "Creatina p/ iniciantes",
                              children: [],
                            },
                            position: { x: 0, y: 0 },
                          },
                        ],
                      },
                      position: { x: 0, y: 0 },
                    },
                  ],
                },
                position: { x: 0, y: 0 },
              },
            ],
          },
          position: { x: 0, y: 0 },
        },
        {
          id: "mental-wellness",
          type: "custom",
          data: {
            label: "Bem estar mental",
            level: "Category",
            isExpanded: false,
            edgeLabel: "Bem estar mental",
            children: [],
          },
          position: { x: 0, y: 0 },
        },
        {
          id: "fitness",
          type: "custom",
          data: {
            label: "Fitness e atividade física",
            level: "Category",
            isExpanded: false,
            edgeLabel: "Fitness e atividade física",
            children: [],
          },
          position: { x: 0, y: 0 },
        },
      ],
    },
    position: { x: 0, y: 0 },
  },
  {
    id: "wealth",
    type: "custom",
    data: {
      label: "Prosperidade",
      level: "CoreMarket",
      isExpanded: false,
      children: [],
    },
    position: { x: 0, y: 0 },
  },
  {
    id: "relationships",
    type: "custom",
    data: {
      label: "Relacionamentos",
      level: "CoreMarket",
      isExpanded: false,
      children: [],
    },
    position: { x: 0, y: 0 },
  },
];

export const useMindMapStore = defineStore("mindMap", {
  state: () => ({
    nodes: initialNodes,
  }),

  getters: {
    // Nós posicionados para o Vue Flow
    flowNodes(state): Node[] {
      const allNodes: Node[] = [];

      const flattenVisible = (root: MindMapNode) => {
        const outNodes: MindMapNode[] = [];
        const outEdges: Edge[] = [];

        const walk = (node: MindMapNode) => {
          outNodes.push({ ...node });
          if (node.data.isExpanded && node.data.children?.length) {
            for (const child of node.data.children) {
              child.parentNode = node.id;
              outEdges.push({
                id: `edge-${node.id}-${child.id}`,
                source: node.id,
                target: child.id,
                type: "smoothstep",
                style: { stroke: "#6b7280", strokeWidth: 1.5 },
                animated: false,
                data: { label: child.data?.edgeLabel },
              } as Edge);
              walk(child);
            }
          }
        };

        walk(root);
        return { nodes: outNodes, edges: outEdges };
      };

      // gaps por nível (colunas) — pode ajustar à vontade
      const levelGaps = [380, 320, 260, 220, 200];
      const rowGaps = [140, 120, 100, 84, 72];

      // Para cada root, achata, faz layout e junta
      state.nodes.forEach((root: MindMapNode, idx: number) => {
        const { nodes, edges } = flattenVisible(root);
        if (!nodes.length) return;

        const positioned = layoutMindMap(nodes, edges, {
          rootId: root.id,
          levelGap: 320,
          rowGap: 120,
          levelGaps,
          rowGaps,
          center: { x: 160, y: 200 + idx * 220 },
        }) as MindMapNode[];

        // garante que ao menos o root apareça mesmo se algo falhar
        if (!positioned || positioned.length === 0) {
          allNodes.push({
            ...root,
            position: { x: 160, y: 200 + idx * 220 },
            draggable: false,
            selectable: false,
          } as MindMapNode);
          return;
        }

        positioned.forEach((n) => allNodes.push(n));
      });

      // fallback global: renderiza roots mesmo se nada vier
      if (allNodes.length === 0 && state.nodes?.length) {
        state.nodes.forEach((root: MindMapNode, idx: number) => {
          allNodes.push({
            ...root,
            position: { x: 160, y: 200 + idx * 220 },
            draggable: false,
            selectable: false,
          } as MindMapNode);
        });
      }

      return allNodes;
    },

    // Arestas derivadas dos nós visíveis/expandidos
    flowEdges(state): Edge[] {
      const allEdges: Edge[] = [];

      const collect = (root: MindMapNode) => {
        const outEdges: Edge[] = [];
        const walk = (node: MindMapNode) => {
          if (node.data.isExpanded && node.data.children?.length) {
            for (const child of node.data.children) {
              outEdges.push({
                id: `edge-${node.id}-${child.id}`,
                source: node.id,
                target: child.id,
                type: "smoothstep",
                style: { stroke: "#6b7280", strokeWidth: 1.5 },
                animated: false,
                data: { label: child.data?.edgeLabel },
              } as Edge);
              walk(child);
            }
          }
        };
        walk(root);
        return outEdges;
      };

      state.nodes.forEach((root: MindMapNode) => {
        collect(root).forEach((e) => allEdges.push(e));
      });

      return allEdges;
    },
  },

  actions: {
    toggleNode(nodeId: string) {
      const findAndToggle = (nodes: MindMapNode[]): boolean => {
        for (const node of nodes) {
          if (node.id === nodeId) {
            node.data.isExpanded = !node.data.isExpanded;
            return true;
          }
          if (node.data.children && findAndToggle(node.data.children)) {
            return true;
          }
        }
        return false;
      };
      findAndToggle(this.nodes);
    },

    // Opcional: usados quando o Vue Flow tenta escrever via v-model
    replaceFlowNodes(_val: Node[]) {
      // no-op: posições são derivadas pelo layout
    },
    replaceFlowEdges(_val: Edge[]) {
      // no-op: edges são derivadas da árvore
    },
  },
});
</file>

<file path="nuxt.config.ts">
import { defineNuxtConfig } from "nuxt/config";
// Local typing for @nuxtjs/tailwindcss config key to satisfy TS in editors
declare module "nuxt/schema" {
  interface NuxtConfig {
    tailwindcss?: {
      cssPath?: string | false;
      configPath?: string;
      exposeConfig?: boolean;
      injectPosition?: number;
      viewer?: boolean;
      editorSupport?: boolean;
      [key: string]: unknown;
    };
  }
  // Ensure NuxtOptions also sees the augmentation
  interface NuxtOptions extends NuxtConfig {}
}
export {};
// https://nuxt.com/docs/api/configuration/nuxt-config
export default defineNuxtConfig({
  // TypeScript configuration
  typescript: {
    strict: true,
    typeCheck: "build",
    shim: false, // Disable shim as we're using takeOver mode
    tsConfig: {
      compilerOptions: {
        target: "ESNext",
        module: "ESNext",
        moduleResolution: "bundler",
        strict: true,
        jsx: "preserve",
        sourceMap: true,
        resolveJsonModule: true,
        isolatedModules: true,
        esModuleInterop: true,
        lib: ["ESNext", "DOM", "DOM.Iterable"],
        skipLibCheck: true,
        noEmit: true,
        baseUrl: ".",
        paths: {
          "~/*": ["./*"],
          "@/*": ["./*"],
        },
        types: ["@pinia/nuxt", "vite/client", "vue", "nuxt/schema"],
      },
      include: [
        "**/*.ts",
        "**/*.d.ts",
        "**/*.tsx",
        "**/*.vue",
        ".nuxt/types/**/*.ts",
        "types/**/*.d.ts",
        "types/**/*.ts",
        "composables/**/*",
        "utils/**/*",
      ],
      exclude: ["node_modules", ".nuxt", ".output", "dist"],
    },
  },

  // Vue configuration
  vue: {
    compilerOptions: {
      isCustomElement: (tag: string) => tag.startsWith("v-"),
      whitespace: "condense",
      comments: false,
    },
  },

  // Pinia configuration is handled by @pinia/nuxt module

  // Vite configuration
  vite: {
    define: {
      "process.env.DEBUG": JSON.stringify(process.env.DEBUG || "false"),
      "process.env.NODE_ENV": JSON.stringify(
        process.env.NODE_ENV || "development"
      ),
    },
    optimizeDeps: {
      include: [
        "vue",
        "@vueuse/core",
        "pinia",
        "vue-router",
        "ofetch",
        "defu",
        "h3",
        "unhead",
      ],
    },
    server: {
      watch: {
        usePolling: true,
        interval: 100,
      },
      hmr: {
        protocol: "ws",
        host: "localhost",
        port: 3000,
        overlay: true,
      },
    },
    css: {
      preprocessorOptions: {
        scss: {
          additionalData: `
            @use "sass:color";
            @use "sass:list";
            @use "sass:map";
            @use "sass:math";
            @use "sass:meta";
            @use "sass:selector";
            @use "sass:string";
            @use "sass:color" as *;
            @import "@/assets/styles/variables";
            @import "@/assets/styles/mixins";
          `,
        },
      },
    },
    vue: {
      script: {
        defineModel: true,
        propsDestructure: true,
      },
    },
    plugins: [
      {
        name: "disable-vue-tsc",
        config: () => ({
          build: {
            rollupOptions: {
              external: ["vite-plugin-checker"],
            },
          },
        }),
      },
    ],
  },

  // Global CSS
  css: ["~/assets/css/tailwind.css"],

  // Modules
  modules: [
    "@nuxtjs/supabase",
    "@vueuse/nuxt",
    [
      "@pinia/nuxt",
      {
        autoImports: ["defineStore", "storeToRefs", "acceptHMRUpdate"],
      },
    ],
    "@nuxtjs/tailwindcss",
  ],

  // Tailwind CSS configuration
  tailwindcss: {
    cssPath: "~/assets/css/tailwind.css",
    configPath: "tailwind.config",
    exposeConfig: false,
    injectPosition: 0,
    viewer: true,
  },

  // Supabase module configuration
  // @ts-ignore - Supabase types are not properly recognized
  supabase: {
    // Use environment variables directly
    url: process.env.SUPABASE_URL,
    key: process.env.SUPABASE_ANON_KEY,

    // Disable built-in redirects
    redirect: false,

    // Client options
    clientOptions: {
      auth: {
        persistSession: true,
        autoRefreshToken: true,
        detectSessionInUrl: true,
      },
    },
  },

  // Components configuration
  components: ["~/components", "~/components/landing"],

  // Auto-imports
  imports: {
    autoImport: true,
  },

  // Runtime config
  runtimeConfig: {
    public: {
      // Will be available on both server and client
      siteUrl: process.env.NUXT_PUBLIC_SITE_URL || "http://localhost:3000",
      supabaseUrl: process.env.SUPABASE_URL || "",
      supabaseAnonKey: process.env.SUPABASE_ANON_KEY || "",
    },
  },
});
</file>

<file path="package.json">
{
  "$schema": "https://json.schemastore.org/package.json",
  "name": "nuxt-app",
  "type": "module",
  "private": true,
  "scripts": {
    "build": "nuxt build",
    "dev": "nuxt dev",
    "generate": "nuxt generate",
    "preview": "nuxt preview",
    "postinstall": "nuxt prepare"
  },
  "dependencies": {
    "@heroicons/vue": "^2.2.0",
    "@nuxtjs/supabase": "^1.6.0",
    "@vue-flow/background": "^1.3.2",
    "@vue-flow/controls": "^1.1.3",
    "@vue-flow/core": "^1.46.0",
    "@vueuse/core": "^13.6.0",
    "nuxt": "^3.0.0",
    "repomix": "^1.3.0",
    "v-click-outside": "^3.2.0",
    "vue": "^3.5.18",
    "vue-router": "^4.5.1"
  },
  "devDependencies": {
    "@nuxt/kit": "^4.0.3",
    "@nuxt/schema": "^4.0.3",
    "@nuxt/types": "^2.18.1",
    "@nuxtjs/i18n": "^10.0.5",
    "@nuxtjs/tailwindcss": "^6.8.0",
    "@pinia/nuxt": "^0.11.2",
    "@types/node": "^24.3.0",
    "@vue/compiler-sfc": "^3.5.18",
    "@vue/runtime-dom": "^3.5.18",
    "@vueuse/nuxt": "^13.6.0",
    "vue-tsc": "^3.0.5"
  }
}
</file>

<file path="components/canvas/MindMapNode.vue">
<template>
  <div
    class="group relative w-auto select-none"
    tabindex="0"
  >
    <Handle
      type="source"
      :position="Position.Right"
      :style="{ opacity: 0, pointerEvents: 'none' }"
    />
    <Handle
      type="target"
      :position="Position.Left"
      :style="{ opacity: 0, pointerEvents: 'none' }"
    />
    <!-- ROOT: sempre card -->
    <div
      v-if="data.level === 'CoreMarket'"
      class="p-4 rounded-lg bg-[#17171C] shadow-lg transition-all duration-200 flex items-start gap-3 border-t border-t-[#47464B]"
    >
      <!-- Node content -->
      <div class="flex-1 min-w-0">
        <div class="flex items-center mb-1">
          <div class="mr-2 flex items-center" v-if="data.iconName">
            <component :is="ICONS[data.iconName]" v-if="ICONS[data.iconName]" />
          </div>
          <div class="font-semibold text-sm flex-grow text-white">
            {{ data.label || label }}
          </div>
        </div>
        <div class="text-xs opacity-90 mt-1" v-if="data.description">
          {{ data.description }}
        </div>
      </div>

      <!-- Output connection point (right) -->
    </div>

    <!-- External connector + button (root) -->
    <div
      v-if="hasChildren && data.level === 'CoreMarket'"
      class="absolute right-[-64px] top-1/2 -translate-y-1/2 flex items-center w-16 h-10 group nodrag nowheel nopan"
      @mousedown.stop
      @pointerdown.stop
      @wheel.stop.prevent
      @touchstart.stop
      @dblclick.stop.prevent
    >
      <!-- connector line (fixed, ends before the button) -->
      <div class="h-[2px] bg-[#5A5A60] flex-grow"></div>
      <!-- outlined circle button drawing +/- with CSS -->
      <button
        type="button"
        @mousedown.stop
        @pointerdown.stop
        @wheel.stop.prevent
        @touchstart.stop
        @click.stop="toggle"
        @dblclick.stop.prevent
        aria-label="Expandir/contrair"
        class="z-10 w-8 h-8 rounded-full border-2 border-[#5A5A60] bg-[#0d0d12] shadow-sm transition-transform hover:scale-[1.03] relative before:content-[''] before:absolute before:left-1/2 before:top-1/2 before:-translate-x-1/2 before:-translate-y-1/2 before:w-2.5 before:h-[2px] before:bg-[#5A5A60] before:rounded hover:border-[#8E6CE4] hover:before:bg-[#8E6CE4] hover:after:bg-[#8E6CE4] nodrag nowheel nopan"
        style="touch-action: manipulation"
        :class="{
          // show vertical bar only when collapsed (plus)
          'after:content-[\'\'] after:absolute after:left-1/2 after:top-1/2 after:-translate-x-1/2 after:-translate-y-1/2 after:w-[2px] after:h-2.5 after:bg-[#5A5A60] after:rounded':
            !isExpanded,
        }"
      />
    </div>

    <!-- Non-root nodes with BaseNodeShell -->
    <div v-if="data.level !== 'CoreMarket'" class="relative w-full h-full">
      <BaseNodeShell
        :width="192"
        :height="100"
        class="block relative"
        :data-node-id="props.id"
        :showOverlay="showOverlay"
        @mouseenter="onRootMouseEnter"
        @mouseleave="onRootMouseLeave"
      >
        <!-- Lightweight text (always in DOM, toggles opacity) -->
        <LightweightText
          :label="data.label || label"
          :reserveRight="hasChildren"
          :class="showOverlay ? 'opacity-0' : 'opacity-100'"
          :aria-hidden="showOverlay ? 'true' : 'false'"
        />

        <!-- Card overlay (conditionally rendered) -->
        <template #overlay>
          <div class="absolute inset-0 z-10 w-full h-full" style="pointer-events: auto;">
            <CardOverlay
              :label="data.label || label"
              :description="data.description"
              :selected="selected"
              @primary="data.onPrimary?.()"
            >
              <template #icon>
                <component
                  :is="ICONS[data.iconName]"
                  v-if="data.iconName && ICONS[data.iconName]"
                />
              </template>
            </CardOverlay>
          </div>
        </template>
      </BaseNodeShell>

      <!-- External connector + button (non-root, shows on hover) -->
      <div
        v-if="hasChildren && data.level !== 'CoreMarket'"
        class="absolute right-[-64px] top-1/2 -translate-y-1/2 flex items-center w-16 h-10 opacity-0 group-hover:opacity-100 group-focus-visible:opacity-100 transition-opacity group nodrag nowheel nopan"
        @mousedown.stop
        @pointerdown.stop
        @wheel.stop.prevent
        @touchstart.stop
        @dblclick.stop.prevent
      >
        <div class="h-[2px] bg-[#5A5A60]"></div>
        <button
          type="button"
          @mousedown.stop
          @pointerdown.stop
          @wheel.stop.prevent
          @touchstart.stop
          @click.stop="toggle"
          @dblclick.stop.prevent
          aria-label="Expandir/contrair"
          class="z-10 w-8 h-8 rounded-full border-2 border-[#5A5A60] bg-[#0d0d12] shadow-sm transition-transform hover:scale-[1.03] relative before:content-[''] before:absolute before:left-1/2 before:top-1/2 before:-translate-x-1/2 before:-translate-y-1/2 before:w-2.5 before:h-[2px] before:bg-[#5A5A60] before:rounded hover:border-[#8E6CE4] hover:before:bg-[#8E6CE4] hover:after:bg-[#8E6CE4] nodrag nowheel nopan"
          style="touch-action: manipulation"
          :class="{
            'after:content-[\'\'\'] after:absolute after:left-1/2 after:top-1/2 after:-translate-x-1/2 after:-translate-y-1/2 after:w-[2px] after:h-2.5 after:bg-[#5A5A60] after:rounded':
              !isExpanded,
          }"
        />
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import HeartIcon from "~/components/icon/HeartIcon.vue";
// Simple nextTick implementation as a fallback
const nextTick = () => new Promise(resolve => setTimeout(resolve, 0));
import LightweightText from "~/components/canvas/node/LightweightText.vue";
import BaseNodeShell from "~/components/canvas/base/BaseNodeShell.vue";
import CardOverlay from "~/components/canvas/node/CardOverlay.vue";

// Use Vue Flow and store
const { useVueFlow } = await import("@vue-flow/core");
const { useMindMapStore } = await import("~/stores/mindMapStore");
const { Handle, Position } = await import("@vue-flow/core");

// const isHovered = ref(false);  // Removed as per instructions
const store = useMindMapStore();
const { updateNodeInternals } = useVueFlow();

// Non-reactive icon registry
const ICONS: Record<string, any> = {
  heart: HeartIcon,
};

// Component props
const props = defineProps({
  id: {
    type: String,
    required: true,
  },
  data: {
    type: Object,
    required: true,
    default: () => ({
      level: "Category",
      isExpanded: false,
      children: [],
    }),
  },
  label: {
    type: String,
    default: "",
  },
  type: {
    type: String,
    default: "default",
  },
  selected: {
    type: Boolean,
    default: false,
  },
  isConnectable: {
    type: Boolean,
    default: true,
  },
  position: {
    type: Object,
    required: true,
    default: () => ({ x: 0, y: 0 }),
  },
  // Vue Flow connection points
  sourcePosition: {
    type: String,
    default: "right",
  },
  targetPosition: {
    type: String,
    default: "left",
  },
});

// Computed properties
const hasChildren = computed(
  (): boolean => (props.data?.children?.length ?? 0) > 0
);

const isExpanded = computed(() => {
  return !!props.data?.isExpanded;
});


// Track hover state for the node locally
const isHovered = ref(false);

// Debug logging for hover state changes
watch(isHovered, (newVal: boolean) => {
  console.log(`[MindMapNode] Hover state changed: ${newVal}`, {
    nodeId: props.id,
    label: props.data?.label || props.label,
    timestamp: new Date().toISOString()
  });
});

// Show overlay based on local hover state
const showOverlay = computed<boolean>(() => {
  const shouldShow = isHovered.value;
  console.log(`[MindMapNode] showOverlay: ${shouldShow}`, {
    nodeId: props.id,
    label: props.data?.label || props.label,
    timestamp: new Date().toISOString()
  });
  return shouldShow;
});

// Update node internals when overlay visibility changes
watch(() => showOverlay.value, async (isShowing: boolean) => {
  if (isShowing && typeof window !== "undefined") {
    await nextTick();
    await new Promise(resolve => requestAnimationFrame(resolve));
    updateNodeInternals(props.id);
  }
});

function onRootMouseEnter(event: MouseEvent) {
  if (props.data?.level === "CoreMarket") return;
  
  event.stopPropagation();
  event.stopImmediatePropagation();
  
  console.log('[MindMapNode] Mouse enter:', {
    nodeId: props.id,
    label: props.data?.label || props.label,
    target: event.target,
    currentTarget: event.currentTarget,
    timestamp: new Date().toISOString()
  });
  
  isHovered.value = true;
  
  // Force Vue Flow to update the node
  if (typeof window !== 'undefined') {
    requestAnimationFrame(() => {
      console.log('[MindMapNode] Updating node internals after mouse enter');
      updateNodeInternals(props.id);
    });
  }
}

function onRootMouseLeave(event: MouseEvent) {
  if (props.data?.level === "CoreMarket") return;
  
  event.stopPropagation();
  event.stopImmediatePropagation();
  
  console.log('[MindMapNode] Mouse leave:', {
    nodeId: props.id,
    label: props.data?.label || props.label,
    target: event.target,
    currentTarget: event.currentTarget,
    timestamp: new Date().toISOString()
  });
  
  isHovered.value = false;
  
  // Force Vue Flow to update the node
  if (typeof window !== 'undefined') {
    requestAnimationFrame(() => {
      console.log('[MindMapNode] Updating node internals after mouse leave');
      updateNodeInternals(props.id);
    });
  }
}


// Toggle node expansion
const toggle = () => {
  store.toggleNode(props.id);
  // Force Vue Flow to recalculate after state change on the next frame
  if (typeof window !== "undefined") {
    requestAnimationFrame(() => {
      updateNodeInternals();
    });
  }
};

// Expose connection points for Vue Flow
const connectionPoints = {
  source: "right",
  target: "left",
};

defineExpose({
  connectionPoints,
});
</script>

<style scoped>
.vue-flow__edge-path {
  pointer-events: none;
}
</style>
</file>

<file path="components/Header.vue">
<!-- components/Header.vue -->
<template>
  <header
    class="text-white py-4 px-6 flex items-center justify-between w-full z-[100] h-[72px] relative"
  >
    <!-- Menu Hamburger -->
    <div class="relative" ref="dropdownRef">
      <button
        @click.stop="isOpen = !isOpen"
        class="p-2 rounded-md bg-[#2d2d2f] hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-white"
      >
        <Bars3Icon class="h-6 w-6 text-white" />
      </button>

      <!-- Dropdown Menu -->
      <div
        v-if="isOpen"
        class="origin-top-right absolute left-0 mt-2 w-auto rounded-md shadow-lg bg-[#0D0D12] ring-1 ring-black ring-opacity-5 focus:outline-none z-50"
        role="menu"
        aria-orientation="vertical"
        tabindex="-1"
        style="z-index: 1000"
      >
        <div class="py-1" role="none">
          <button
            @click="handleLogout"
            class="text-gray-200 hover:bg-[#2d2d2f] block w-full text-left px-4 py-2 text-sm"
            role="menuitem"
          >
            Sair
          </button>
        </div>
      </div>
    </div>
  </header>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from "vue";
import { useRouter } from "vue-router";
import { Bars3Icon } from "@heroicons/vue/24/outline";

const isOpen = ref(false);
const dropdownRef = ref(null);
const router = useRouter();

const closeMenu = () => {
  isOpen.value = false;
};

const handleClickOutside = (event) => {
  if (dropdownRef.value && !dropdownRef.value.contains(event.target)) {
    closeMenu();
  }
};

const handleLogout = async () => {
  try {
    // Aqui você pode adicionar a lógica de logout se estiver usando autenticação
    // Por exemplo: await supabase.auth.signOut();

    // Redireciona para a página inicial
    await router.push("/");
  } catch (error) {
    console.error("Erro ao fazer logout:", error);
  } finally {
    closeMenu();
  }
};

// Configura o event listener para clique fora após a montagem do componente
onMounted(() => {
  // Usamos setTimeout para garantir que o event listener só seja adicionado
  // após o clique que abriu o menu ser processado
  setTimeout(() => {
    document.addEventListener("click", handleClickOutside);
  }, 0);
});

// Remove o event listener quando o componente é desmontado
onUnmounted(() => {
  document.removeEventListener("click", handleClickOutside);
});
</script>
</file>

<file path="pages/app.vue">
<template>
  <div class="vue-flow-wrapper h-full w-full relative flex flex-col">
    <Header class="mb-[-72px] z-11" />

    <!-- Search Card -->
    <div class="absolute top-16 left-4 z-10">
      <SearchCard
        v-model="searchQuery"
        placeholder="ex: 'saúde para idosos', 'produtividade'"
        @search="handleSearch"
        class="w-[300px]"
      >
        <template #results>
          <div
            v-if="searchResults.length > 0"
            class="mt-2 w-full bg-[#2C2B30] border border-[#47464B] rounded-lg shadow-lg z-20 max-h-60 overflow-y-auto"
          >
            <div
              v-for="result in searchResults"
              :key="result.id"
              class="px-4 py-2 hover:bg-[#3a393e] cursor-pointer text-white text-sm"
              @click="selectSearchResult(result)"
            >
              {{ result.label }}
            </div>
          </div>
        </template>
      </SearchCard>
    </div>

    <!-- Main Canvas Area -->
    <div class="flex-1 relative">
      <ClientOnly>
        <div ref="flowContainerRef" class="vue-flow-container absolute inset-0">
          <VueFlow
            v-model:nodes="modelNodes"
            v-model:edges="modelEdges"
            :node-types="nodeTypes"
            :default-viewport="{ zoom: 0.8 }"
            :min-zoom="0.5"
            :max-zoom="4"
            :snap-to-grid="false"
            :elevate-nodes-on-select="true"
            :nodes-draggable="false"
            :nodes-connectable="false"
            :edges-updatable="false"
            :elements-selectable="false"
            :default-edge-options="{
              type: 'smoothstep',
              style: { stroke: '#6b7280', strokeWidth: 1.5 },
              animated: false,
            }"
            :node-extent="[
              [0, 0],
              [Infinity, Infinity],
            ]"
            fit-view-on-init
            class="basicflow"
            style="background-color: #0d0d12"
            @node-click="onNodeClick"
            @pane-click="onPaneClick"
            @init="onFlowInit"
          >
            <Background
              pattern-color="#393939"
              color="#292932"
              :gap="40"
              :size="3"
            />
            <Controls :show-interactive="false" />
          </VueFlow>
        </div>
        <template #fallback>
          <div class="flex items-center justify-center h-full w-full">
            <div class="loading loading-spinner loading-lg text-blue-500"></div>
          </div>
        </template>
      </ClientOnly>
    </div>
  </div>
</template>

<script setup>
import { markRaw } from "vue";
import { VueFlow, useVueFlow } from "@vue-flow/core";
import { Background } from "@vue-flow/background";
import { Controls } from "@vue-flow/controls";
import "@vue-flow/core/dist/style.css";
import "@vue-flow/core/dist/theme-default.css";
import "@vue-flow/controls/dist/style.css";

// Components
import Header from "~/components/Header.vue";
import SearchCard from "~/components/SearchCard.vue";
import MindMapNode from "~/components/canvas/MindMapNode.vue";

// Store
import { useMindMapStore } from "~/stores/mindMapStore";

// Composable
const router = useRouter();
const user = useSupabaseUser();
const mindMapStore = useMindMapStore();

// Reactive state
const searchQuery = ref("");
const searchResults = ref([]);
const flowContainerRef = ref(null);

const modelNodes = ref([]);
const modelEdges = ref([]);

const { fitView, viewportInitialized } = useVueFlow();

const flowReady = ref(false);
const onFlowInit = () => {
  flowReady.value = true;
  // wait next tick to ensure DOM nodes are measured
  nextTick(() => {
    try {
      fitView({ padding: 0.2 });
    } catch (e) {
      /* ignore */
    }
  });
};

watch(
  modelNodes,
  async () => {
    await nextTick();
    if (!flowReady.value || !viewportInitialized?.value) return;
    try {
      fitView({ padding: 0.2 });
    } catch (e) {
      /* ignore */
    }
  },
  { immediate: true }
);

watch(
  () => mindMapStore.flowNodes,
  (val) => {
    // Always replace array reference so VueFlow receives updates
    modelNodes.value = Array.isArray(val) ? [...val] : [];
  },
  { immediate: true }
);

watch(
  () => mindMapStore.flowEdges,
  (val) => {
    modelEdges.value = Array.isArray(val) ? [...val] : [];
  },
  { immediate: true }
);

// Computed properties

const nodeTypes = {
  custom: markRaw(MindMapNode),
};

// Handle node click (supports both (event, node) and (node) signatures)
const onNodeClick = (arg1, arg2) => {
  const node = arg2 && arg2.id ? arg2 : arg1 && arg1.id ? arg1 : null;
  if (!node || !node.data) return;

  // Use data.level semantics; fallback to old data.type if present
  const level = node.data.level ?? node.data.type ?? null;
  const isRoot = !!node.data.isRoot;

  // Toggle expand/collapse when root or when node has children
  if (isRoot || (node.data.children && node.data.children.length)) {
    try {
      mindMapStore.toggleNode(node.id);
    } catch (e) {
      console.warn("onNodeClick toggle failed:", e);
    }
  }
};

// Handle pane click (background click)
const onPaneClick = () => {
  searchResults.value = [];
};

// Search functionality
const handleSearch = () => {
  if (!searchQuery.value.trim()) {
    searchResults.value = [];
    return;
  }

  const query = searchQuery.value.toLowerCase();
  const results = [];

  // Simple search implementation
  const searchNodes = (nodes) => {
    nodes.forEach((node) => {
      if (node.data?.label?.toLowerCase().includes(query)) {
        results.push({ id: node.id, label: node.data.label });
      }
      if (node.data?.children) {
        searchNodes(node.data.children);
      }
    });
  };

  searchNodes(mindMapStore.nodes);
  searchResults.value = results;
};

// Handle search result selection
const selectSearchResult = (result) => {
  // TODO: Implement search result selection
  searchQuery.value = "";
  searchResults.value = [];
};

// Redirect to login if not authenticated
onMounted(() => {
  if (process.client && !user.value) {
    router.push("/login");
  }
});
</script>

<style scoped>
.vue-flow-wrapper {
  width: 100%;
  height: 100%;
  background-color: #0d0d12;
}

.vue-flow-container {
  width: 100%;
  height: 100%;
}

:deep(.vue-flow__node) {
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  cursor: grab;
}

:deep(.vue-flow__node.dragging) {
  cursor: grabbing;
  z-index: 1000;
  transform: scale(1.02);
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
}

:deep(.vue-flow__edge-path) {
  pointer-events: none;
}
</style>
</file>

</files>
